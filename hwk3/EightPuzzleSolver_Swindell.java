import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.PriorityQueue;
import java.lang.*;
import java.io.*;
import java.util.Comparator;
import java.util.Collections;
import java.util.Iterator;



class solvedContainer
{
	Child ch;
	int count;
	solvedContainer(Child ch, int count)
	{
		this.ch = ch;
		this.count = count;

	}
}

class Relative
{
	Node node;
	String action;
	int expansionNumber = -1;
	Relative(Node n, String a)
	{
		this.node = n;
		this.action = a;
	}
	
	Relative(Node n, String a, int expno)
	{
		this.node = n;
		this.action = a;
		this.expansionNumber = expno;
	}

}

class Parent extends Relative
{
	Parent(Node n, String a)
	{
		super(n, a);
	}
	Parent(Node n, String a, int expno)
	{
		super(n, a, expno);
	}

	public String toString()
	{
		String retn="{state : [";
		for(int ii=0; ii<9; ii++)
		{
			if(ii != 8 )
				retn+=this.node.getState()[ii]+", ";
			else
				retn+=this.node.getState()[ii]+"], ";
		}
		retn+="action: " + this.action + ", ";
		retn+="hDipslaced: " + this.node.getHDisplaced() + ", ";
		retn+="gVal: " + this.node.getGVal() + ", ";
		retn+="hManhattan: " + this.node.getHManhattan()+ ", ";  
		retn+="expNumber: "+this.expansionNumber + "}";


		return retn;
	}

}

/*
 * Child Class
 * This class is made to contain a child node 
 * generated by Node.expand() along with the 
 * action undertaken by the expand function 
 * go generate the child node
 * */
class Child extends Relative
{	
	Child(Node n, String a)
	{
		super(n, a);
	}	
	Child(Node n, String a, int expno)
	{
		super(n, a, expno);
	}	

	public String toString()
	{
		String retn="{state : [";
		for(int ii=0; ii<9; ii++)
		{
			if(ii != 8 )
				retn+=this.node.getState()[ii]+", ";
			else
				retn+=this.node.getState()[ii]+"], ";
		}
		retn+="action: " + this.action + ", ";
		retn+="hDipslaced: " + this.node.getHDisplaced() + ", ";
		retn+="gVal: " + this.node.getGVal() + ", ";
		retn+="hManhattan: " + this.node.getHManhattan();  
		retn+="expNumber: "+this.expansionNumber +" }";


		return retn;
	}
}



class Node 
{
	//fields
	//(i)
	private int state[] = {1, 2, 3, 8, 0, 4, 7, 6, 5};

	//(ii)
	private Parent parent;

	//(iii) 
	//// No. of displaced tiles; (no. tiles not in desired location)
	private int hDisplaced=0;	

	// The sum of block distances 
	// of tiles from desired location
	private int hManhattan; 

	//gVal of parent + 1
	private int gVal=0;


	//(iv)
	//list of child nodes
	ArrayList<Child> children = new ArrayList<Child>();

	
	//Constructor
	Node( int _state[], Parent _parent )
	{
		
		this.state = _state;
		this.parent = _parent;
		if( this.parent !=  null)
			this.gVal = this.parent.node.gVal+1;

		setHDisplaced();
		setHManhattan();
		
	}

	//setters and getters
	private void setHDisplaced()
	{

		for(int tile_pos=1; tile_pos<this.state.length+1; tile_pos++)
		{
			int label = this.state[tile_pos-1];
			if(label != 0)
			{
				if(label != tile_pos)
					this.hDisplaced+=1;
			}
		}
	}

	public int getHDisplaced()
	{
		return this.hDisplaced;
	}

	public int getGVal()
	{
		return this.gVal;
	}
	public int getHManhattan()
	{
		return this.hManhattan;
	}

	public int getGval()
	{
		return this.gVal;
	}
	
	private void setHManhattan()
	{
		for(int tile_pos=1; tile_pos<this.state.length+1; tile_pos++)
		{
			int label = this.state[tile_pos-1];
			if(label != 0)
			{
				this.hManhattan += Math.abs(tile_pos-label);
			}
		}

	}

	public ArrayList<Parent> getLineage()
	{
		Parent myParent = this.getParent();
		ArrayList<Parent> lineage = new ArrayList<Parent>();
		while( myParent != null )
		{
			lineage.add(myParent);
			myParent = myParent.node.getParent();
		}

		Collections.reverse(lineage);
		return lineage;
	}


	public ArrayList<Child> getChildren()
	{
		return this.children;
	}	
	
	public int[] getState()
	{
		return this.state;
	}


	//end setters and getter

	//Methods
	//(v)
	//True if states in the two node objects are equal
	public static boolean equalState(Node n1, Node n2)
	{
		return Arrays.equals(n1.state, n2.state);
	}

	public boolean goalState()
	{
		int goal[] = {1, 2, 3, 4, 5, 6, 7, 8, 0};
		return Arrays.equals(this.state, goal);
	}

	public boolean isChildOf(int[] other_state)
	{
		Parent ancestor = this.getParent();
		while( ancestor != null )// until root node
		{//Iterate through ancestors
			if( ancestor.node.equalState(other_state) )
			{
				return true;
			}
			ancestor = ancestor.node.getParent();
			
		
		}
		return false;
	}
	public boolean eqaulState(Node n)
	{//compare with self
		return Arrays.equals(n.state, this.state);
	}
	
	public boolean equalState(int[] other_state)
	{//compare with self
		return Arrays.equals(this.state, other_state);
	}

	public Parent getParent()
	{
		return this.parent;
	}

	/*
	 * Finds the position of the blank square
	 * in cartesian coordinates.
	 * */
	public int[] getPosition(int num)
	{	
		boolean gotit=false;
		int resp[] = {0, 0};
		for( int ii=0; ii<3; ii++ )
		{
			for(int jj=0; jj<3; jj++)
			{
				if( this.state[3*ii+jj] == num )
				{
					resp[0] = ii;
					resp[1] = jj;
					return resp;
				}
			}	
		}
		throw new IndexOutOfBoundsException("num not in state array");
	}

	/*
	 * Generates the new state of a child 
	 * from operating on the original state 
	 * with action
	 *
	 * Returns null if the action is not possible
	 * */
	public int[] changeState(String action)
	{
		int pos[] = this.getPosition();
		int ii = pos[0];
		int jj = pos[1];
		
		int newState[] = this.state.clone();
		switch (action)
		{
			case "U":
				if( ii == 0)
				{
				      return null;
				}
				else
				{
				
				      newState[(3*(ii-1))+jj] = 0;
				      newState[3*ii+jj] = this.state[((3*(ii-1))+jj)];
				}
			      	break;

			case "D":
				if( ii == 2)
				{
				      return null;
				}
				else
				{
				
				      newState[(3*(ii+1))+jj] = 0;
				      newState[3*ii+jj] = this.state[(3*(ii+1)+jj)];
				}
			      	break;
		      case "L":
				if( jj == 0)
				{
				      return null;
				}
				else
				{
				      newState[(3*ii)+jj-1] = 0;
				      newState[3*ii+jj] = this.state[((3*ii)+jj-1)];
				}
			      	break;

		      case "R":
				if( jj == 2)
				{
				      return null;
				}
				else
				{
				      newState[(3*ii)+jj+1] = 0;
				      newState[3*ii+jj] = this.state[((3*ii)+jj+1)];
				}
			      	break;
		}
		return newState;
	}

	//A pretty printing of the state 
	//in row/column form.
	public String getStringState()
	{
		String retn=new String();
		for( int ii=0; ii<3; ii++ )
		{
			for(int jj=0; jj<3; jj++)
			{
				retn+=state[3*ii+jj]+" ";
			}
			
			retn+="\n";
		}
		
		return retn;
	}
	
	public String getSimpleState()
	{
		String retn=new String();
		for(int ii=0; ii<this.state.length; ii++)
		{
				retn+=state[ii];
				if(ii != this.state.length-1)
				{
					retn+=",";
				}
			
			//retn+="\n";
		}
		
		return retn;
	}

	/*
	 * Iterates through the four possible actions
	 * and generates the child nodes from these 
	 * actions. Builds the children arraylist field
	 * */
	public void expand(int expnum)
	{
		String actions[] = {"U", "D", "L", "R"};
		boolean wasNull = false;

		for(String act : actions)
		{
			int newState[] = this.changeState(act);

			if(newState  == null)
				continue;

			if( this.isChildOf( newState ) )
				continue;
			
			Node dummy = new Node( newState, new Parent(this, act, expnum) );
			//dummy.state = newState;
			this.children.add( new Child( dummy, act, expnum ) );



		}	

	}

	
	public String toString()
	{
		String retn="{state : [";
		for(int ii=0; ii<9; ii++)
		{
			if(ii != 8)
				retn+=this.state[ii]+", ";
			else
				retn+=this.state[ii]+"],";
		}
		retn+="hDipslaced : "+this.hDisplaced+",";
		retn+="gVal : "+this.gVal+",";
		retn+="hManhattan : "+this.hManhattan+" }";


		return retn;
	}

	public int[] getPosition()
	{
		return this.getPosition(0);
	}

	public void printPosition(int num)
	{
		int pos[] = this.getPosition(num);
		System.out.println("[ "+pos[0]+", "+pos[1]+" ]");
	}

	public void printPosition()
	{
		int pos[] = this.getPosition();
		System.out.println("[ "+pos[0]+", "+pos[1]+" ]");
	}

	//sort the children based on specific criteria
	public ArrayList<Child> sortChildrenByHDisplaced()
	{
		ArrayList<Child> sortedNodes = new ArrayList<Child>();
		for(Child child : this.children)
		{
			sortedNodes.add(child);
		}
		Collections.sort(sortedNodes, new SortByHDisplaced());
		return sortedNodes;
	}
	
	//sort the children based on specific criteria
	public ArrayList<Child> sortChildrenByHManhattan()
	{
		ArrayList<Child> sortedNodes = new ArrayList<Child>();
		for(Child child : this.children)
		{
			sortedNodes.add(child);
		}
		Collections.sort(sortedNodes, new SortByHManhattan());
		return sortedNodes;
	}
	
	//sort the children based on specific criteria
	public ArrayList<Child> sortChildrenByBoth()
	{
		ArrayList<Child> sortedNodes = new ArrayList<Child>();
		for(Child child : this.children)
		{
			sortedNodes.add(child);
		}
		Collections.sort(sortedNodes, new SortByBoth());
		return sortedNodes;
	}

	//End Methods

	
}


//Sorting comparators. 
class SortByHDisplaced implements Comparator<Child>
{
	@Override
	public int compare(Child n1, Child n2)
	{
		return (n1.node.getHDisplaced()+n1.node.getGval()) - (n2.node.getHDisplaced() + n2.node.getGval());
	}
}


class SortByHManhattan implements Comparator<Child>
{
	@Override
	public int compare(Child n1, Child n2)
	{
		return (n1.node.getHManhattan() + n1.node.getGval()) - (n2.node.getHManhattan() + n2.node.getGval());
	}
}

class SortByBoth implements Comparator<Child>
{
	@Override
	public int compare(Child n1, Child n2)
	{
		return (n1.node.getHManhattan() +
				n1.node.getHDisplaced() + 
				n1.node.getGval()) - 
				(n2.node.getHManhattan() + 
				 n2.node.getHDisplaced() +
				 n2.node.getGval());
	}
}



public class hwk3prob3
{
	public enum Hueristic
	{
		DISPLACED,
		MANHATTAN,
		BOTH;
	}

	public static void main(String[] args) throws Exception
	{
		//prob3();
		/*
		generateProblems(5);
		generateProblems(10);
		generateProblems(15);
		System.exit(0);
		*/
		int set=0;
		int problem=0;
		try
		{
			Scanner reader = new Scanner(new File("inputFile.txt"));
			int lineNo=1;
			solvedContainer soltn;
			ArrayList<Parent> soltnLineage = null;
			FileWriter fh;
			BufferedWriter OutHueristic;
			int hnum=0;
			for( Hueristic h : Hueristic.values() )
			{

				switch(h)
				{
					case DISPLACED:
						hnum=1;
						break;
					case MANHATTAN:
						hnum=2;
						break;
					case BOTH:
						hnum=3;
						break;

				}
				fh = new FileWriter("OutfileHeuristic"+hnum+".txt");
				OutHueristic = new BufferedWriter(fh);	

			
				OutHueristic.write("################### Using Heuristic "+h+"###################\n");

				while( reader.hasNextLine() )
				{
					if(lineNo == 1)
					{
						OutHueristic.write("START OF PROBLEM SET 1\n");
						set=1;
						problem=1;
					}
					else if( lineNo == 6 )
					{
						OutHueristic.write("START OF PROBLEM SET 2\n");
						set=2;
						problem=1;
					}
					else if( lineNo== 11)
					{
						OutHueristic.write("START OF PROBLEM SET 3\n");
						set=3;
						problem=1;
					}
					OutHueristic.write("\tProblem "+problem+" Set "+set+"\n");
					Node nd = parseLine(reader.nextLine());
					
					soltn = solve(nd, h);
					for(Parent ancestor : soltn.ch.node.getLineage())
					{
						OutHueristic.write("\t"+ancestor.toString() + "\n");
					}
					lineNo++;
					problem++;
				}	
				OutHueristic.close();

			}

		}
		catch(FileNotFoundException e)
		{
			System.out.println( "inputFile.txt must be present in this directory"  );
			System.exit(0);
		}

	}

	public static Node parseLine(String line)
	{
		int[] initState = new int[9];
		String aline[] = line.split(",");

		int pos=0;
		for(String num : aline)
		{//Iterate through each number in the line to generate node

			initState[pos] = Integer.parseInt(num);
			pos++;
		}
		Node node = new Node(initState, null);
		return node;
	}


	public static solvedContainer solve(Node node, Hueristic hueristic)
	{
		solvedContainer retn = null;
		node.expand(0);
		PriorityQueue<Child> hdq;
		switch (hueristic)
		{
			case DISPLACED:
				hdq = new PriorityQueue<Child>(5, new SortByHDisplaced());
				break;
			case MANHATTAN:
				hdq = new PriorityQueue<Child>(5, new SortByHManhattan());
				break;
			case BOTH:
				hdq = new PriorityQueue<Child>(5, new SortByBoth());
				break;
			default:
				System.out.println("BAD HUERISTIC");
				throw ( new IllegalArgumentException());

		}		
		for( Child firstGen : node.getChildren() )
		{
			hdq.add(firstGen);
			//System.out.println(child.node.goalState() );
		}
		
		int count = 1;
		while(true)
		{
			Child ch = hdq.poll();

			
			if (ch.node.goalState())
			{
				retn = new solvedContainer(ch, count);
				break;
			}

			ch.node.expand(count);
			count++;
			for( Child descendants : ch.node.getChildren() )
	        {
        	    hdq.add(descendants);
    	    }


		}
		return retn;
	}


	public static void generateProblems(int nMoves)
	{
		int state[] = {1, 2, 3, 8, 4, 6, 7, 5, 0};
		ArrayList<Child> probs = new ArrayList<Child>();
		ArrayList<Child> buffer = new ArrayList<Child>();
		Node node = new Node(state, null);
        node.expand(0);
		
		ArrayList<Child> nextGen = node.getChildren();

		for(int ii=0; ii<nMoves-1; ii++)
		{
			for(Child child : nextGen)
			{
				child.node.expand(0);
				buffer.addAll(child.node.getChildren());

			}
			nextGen.clear();
			nextGen.addAll(buffer);
			buffer.clear();
		}

		for(int ii=0; ii<5; ii++)

			//System.out.println( nextGen.get(ii).node.toString() );
			System.out.println( nextGen.get(ii).node.getSimpleState() );
	}
}
